// 1.1
// Реализуйте структуру данных типа “множество строк” на основе динамической хеш-таблицы с открытой адресацией.
// Хранимые строки непустые и состоят из строчных латинских букв.
// Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.
// Начальный размер таблицы должен быть равным 8-ми.
// Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.
// Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.
//
// Вариант 1. Для разрешения коллизий используйте квадратичное пробирование.
// i-ая проба g(k, i)=g(k, i-1) + i (mod m). m - степень двойки.


#include <iostream>
#include <vector>
#include <string>

const size_t DEFAULT_SIZE = 8;

class StringHasher {
private:
    size_t prime;

public:
    StringHasher(size_t prime = 71) : prime(prime) {}

    size_t operator()(const std::string& str, size_t iteration){
        size_t hash = 0;
        for (size_t i = 0; i < str.size(); ++i)
            hash = hash * prime + str[i];
        
        
        return hash + iteration / 2 + (iteration * iteration) / 2;
    }
};

template <typename T>
struct Node{
    T key;
    bool isDeleted;
    bool isEmpty;

    Node() : key(), isDeleted(false), isEmpty(true) {}
};

template <typename T, typename Hasher>
class Hashtable {
private:
    std::vector<Node<T>> table;
    size_t size;
    Hasher hasher;

    void grow() {
        std::vector<Node<T>> newTable(table.size() * 2);
        size_t newSize = 0;

        for (size_t i = 0; i < table.size(); ++i){
            Node<T> node = table[i];
            if (!node.isEmpty && !node.isDeleted){
                for (size_t iter = 0; iter < newTable.size(); ++iter){
                    size_t hash = (hasher(node.key, iter)) % newTable.size();
                    if (newTable[hash].isEmpty) {
                        newTable[hash].key = node.key;
                        newTable[hash].isEmpty = false;
                        newTable[hash].isDeleted = false;
                        newSize++;
                        break;
                    }
                }
            }
        }

        std::swap(table, newTable);
    }

public:
    Hashtable(size_t initial_size = DEFAULT_SIZE) : size(0), table(initial_size) {}
    ~Hashtable() {}
    
    bool Add(const T& key) {
        if (size * 4 >= table.size() * 3) grow();

        size_t delPos = -1;
        for (size_t i = 0; i < table.size(); ++i){
            size_t hash = (hasher(key, i)) % table.size();

            if (!table[hash].isDeleted && table[hash].key == key) return false;

            if (table[hash].isEmpty){
                if (delPos != -1) {
                    hash = delPos;
                }
                table[hash].key = key;
                table[hash].isEmpty = false;
                table[hash].isDeleted = false;
                ++size;
                return true;
            }

            if (table[hash].isDeleted && delPos == -1) delPos = hash;
        }

        if (delPos != -1){
            table[delPos].key = key;
            table[delPos].isEmpty = false;
            table[delPos].isDeleted = false;
            ++size;
            return true;
        }

        return false;
    }

    bool Has(const T& key) {
        for (size_t i = 0; i < table.size(); ++i){
            size_t hash = (hasher(key, i)) % table.size();

            if (table[hash].isEmpty) return false;

            if (!table[hash].isDeleted && table[hash].key == key) return true;
            
        }
        return false;
    }

    bool Delete(const T& key) {
        for (size_t i = 0; i < table.size(); ++i){
            size_t hash = (hasher(key, i)) % table.size();

            if (table[hash].isEmpty) return false;

            if (!table[hash].isDeleted && table[hash].key == key){
                table[hash].isDeleted = true;
                --size;
                return true;
            }
        }
        return false;
    }
};

void run(std::istream& input, std::ostream& output){
    Hashtable<std::string, StringHasher> table;

    char op;
    std::string key;

    while (input >> op >> key) {
        switch (op) {
            case '?':
                output << (table.Has(key) ? "OK" : "FAIL") << '\n';
                break;
            case '+':
                output << (table.Add(key) ? "OK" : "FAIL") << '\n';
                break;
            case '-':
                output << (table.Delete(key) ? "OK" : "FAIL") << '\n';
                break;
        }
    }
}

int main() {
    run(std::cin, std::cout);
    return 0;
}
