// 5.1
// В супермаркете решили оптимизировать показ рекламы.
// Известно расписание прихода и ухода покупателей (два целых числа).
// Каждому покупателю необходимо показать минимум 2 рекламы.
// Рекламу можно транслировать только в целочисленные моменты времени.
// Покупатель может видеть рекламу от момента прихода до момента ухода из магазина.
// В каждый момент времени может показываться только одна реклама.
// Считается, что реклама показывается мгновенно.
// Если реклама показывается в момент ухода или прихода, то считается, что посетитель успел её посмотреть.
// Требуется определить минимальное число показов рекламы.

#include <iostream>
#include <sstream>
#include <cassert>

struct Customer {
    int arrivalTime;
    int depatureTime;

    Customer()
    : arrivalTime(0), depatureTime(0) {}

    Customer(int arrive, int depature)
    : arrivalTime(arrive), depatureTime(depature) {}

    static bool compareTo(const Customer& a, const Customer& b){
        if (a.depatureTime != b.depatureTime) return b.depatureTime > a.depatureTime;
        else return b.arrivalTime < a.arrivalTime;
    }
};

template <typename T, typename Comparator = std::less<T>>
void merge(T* arr, int start, int end, Comparator cmp = Comparator()){
    int mid = start + (end - start)/2;

    int len1 = mid + 1 - start;
    int len2 = end - mid;

    T* buf1 = new T[len1];
    T* buf2 = new T[len2];

    for(int i = 0; i < len1; ++i)
        buf1[i] = arr[start + i];
    for(int j = 0; j < len2; ++j)
        buf2[j] = arr[mid + 1 + j];

    int i = 0, j = 0;
    int startPoint = start;
    while (i < len1 && j < len2){
        if (cmp(buf1[i], buf2[j])) arr[startPoint++] = buf1[i++];
        else arr[startPoint++] = buf2[j++];
    }
    while (i < len1)
        arr[startPoint++] = buf1[i++];
    while (j < len2)
        arr[startPoint++] = buf2[j++];

    delete[] buf1;
    delete[] buf2;
}

template <typename T, typename Comparator = std::less<T>>
void mergeSort(T *arr, int start, int end, Comparator cmp = Comparator()){
    if (start < end){
        int mid = start + (end - start)/2;
        mergeSort(arr, start, mid, cmp);
        mergeSort(arr, mid + 1, end, cmp);

        merge(arr, start, end, cmp);
    }
}

int numberOfAdvertisements(Customer* customerArr, int k, std::istream &input, std::ostream &output){
    mergeSort(customerArr, 0, k - 1, Customer::compareTo);
        
    int preLastAdvertisement = customerArr[0].depatureTime - 1;
    int lastAdvertisement = customerArr[0].depatureTime;
    int countAdvertisements = 2;
    
    for (int i = 1; i < k; ++i){
        if (lastAdvertisement == customerArr[i].depatureTime) continue;
        if (lastAdvertisement >= customerArr[i].arrivalTime){
            if (preLastAdvertisement >= customerArr[i].arrivalTime)
                continue;
            
            countAdvertisements++;
            preLastAdvertisement = lastAdvertisement;
            lastAdvertisement = customerArr[i].depatureTime;
        }else{
            countAdvertisements += 2;
            preLastAdvertisement = customerArr[i].depatureTime - 1;
            lastAdvertisement = customerArr[i].depatureTime;
        }
    }
    return countAdvertisements;
}
void run(std::istream &input, std::ostream &output)
{
    int k;
    input >> k;
    Customer* customerArr = new Customer[k];
    for (int i = 0; i < k; ++i){
        Customer customer;
        input >> customer.arrivalTime >> customer.depatureTime;
        customerArr[i] = customer;
    }

    output << numberOfAdvertisements(customerArr, k, input, output) << std::endl;
    delete[] customerArr;
}


int main() {
    
    run(std::cin, std::cout);
    return 0;
}

