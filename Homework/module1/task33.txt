// 3.3
// Реализовать очередь с помощью двух стеков.
// Требования: Очередь должна быть реализована в виде класса.
// Стек тоже должен быть реализован в виде класса (на основе динамического массива).


#include <iostream>
#include <sstream>
#include <cassert>
#include <random>

class ArrayList{
private:
    int* arr;
    int arrSize;
    int realSize;
    int defaulInitialSize = 2;
    void resize(){
        int newArrSize = std::max(arrSize * 2, defaulInitialSize);
        int* newArr = new int[newArrSize];
        for (int i = 0; i < realSize; ++i)
            newArr[i] = arr[i];
        delete [] arr;
        arr = newArr;
        arrSize = newArrSize;
    }
public:
    ArrayList()
    :arr(0), arrSize(0), realSize(0) {}
    ~ArrayList() {
        delete [] arr;
    }
    
    int size() const{
        return realSize;
    }
    
    int getAt(int idx) const {
        assert(idx >= 0 && idx < realSize && arr != 0);
        return arr[idx];
    }
    
    void pushBack(int val){
        if (realSize == arrSize) resize();
        
        assert(realSize < arrSize && arr != 0);
        arr[realSize++] = val;
    }
    
};


class Stack{
private:
    ArrayList* stack;
    int pointer;
public:
    Stack()
    : stack(new ArrayList()), pointer(-1) {}
    
    Stack(const Stack &other) = delete;
    Stack& operator=(const Stack &other) = delete;
    
    ~Stack(){
        while(!isEmpty())
            pop();
    }
    
    void push(int val){
        stack->pushBack(val);
        pointer++;
    }
    int pop(){
        if (isEmpty()) return -1;
        
        return stack->getAt(pointer--);
    }
    bool isEmpty(){
        return pointer == -1;
    }
};

class Queue{
private:
    Stack* write;
    Stack* read;
    void fillRead(){
        while(!write->isEmpty())
            read->push(write->pop());
    }
public:
    Queue()
    : write(new Stack()), read(new Stack()) {}
    
    Queue(const Queue &other) = delete;
    Queue& operator=(const Queue &other) = delete;
        
    ~Queue()
    {
        while (!write->isEmpty()) write->pop();
        while (!read->isEmpty()) read->pop();
        
    }
    
    int dequeue(){
        if (isEmpty()) return -1;
        
        if (read->isEmpty())
            fillRead();
        return read->pop();
    }
    
    void enqueue(int val){
        write->push(val);
    }
    bool isEmpty(){
        return write->isEmpty() && read->isEmpty();
    }
};



void testLogic()
{
    Queue queue;
    int sampleCount = 1000;
    int a[1000];
    
    assert(queue.isEmpty());
    srand(2);
    for (int i = 0; i < sampleCount; i++)
    {
        int temp = rand()%1001;
        queue.enqueue(temp);
        a[i] = temp;
    }
    
    assert(!queue.isEmpty());
    
    for (int i = 0; i < sampleCount; i++)
    {
//        std::cout << 3queue.dequeue() << " " << a[i] << std::endl;
        assert(a[i] == queue.dequeue());
    }
    
    assert(queue.isEmpty());
}

void run(std::istream &input, std::ostream &output)
{
    Queue* queue = new Queue();
    
    int n = 0;
    input >> n;
    bool check = true;
    for (int i = 0; i < n; i++){
        int op = 0, val = 0;
        input >> op >> val;
        
        switch (op){
            case 2:{
                int tmpVal = queue->dequeue();
                if (tmpVal != val){
                    check = false;
                }
                break;
            }
            case 3:{
                queue->enqueue(val);
                break;
            }
        }
    }
    check ? output << "YES" << std::endl : output << "NO" << std::endl;
}

void testQueue()
{
    {
        std::stringstream input, output;
        input << "3" << std::endl;
        input << "3 111" << std::endl;
        input << "2 222" << std::endl;
        input << "3 333" << std::endl;
        run(input, output);
        assert(output.str() == "NO\n");
    }
    {
        std::stringstream input, output;
        input << "3" << std::endl;
        input << "3 111" << std::endl;
        input << "2 111" << std::endl;
        input << "3 333" << std::endl;
        run(input, output);
        assert(output.str() == "YES\n");
    }
}

int main() {
//    testLogic();
    run(std::cin, std::cout);
//    testQueue();
    return 0;
}

